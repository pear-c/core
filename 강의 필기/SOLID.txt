■ SOLID
: 좋은 객체 지향 설계의 5가지 원칙

1. SRP : 단일 책임 원칙
2. OCP : 개방-폐쇄 원칙
3. LSP : 리스코프 치환 원칙
4. ISP : 인터페이스 분리 원칙
5. DIP : 의존관계 역전 원칙

1. SRP : 단일 책임 원칙
- 한 클래스는 하나의 책임만 가져야 한다.
- 중요한 기준은 변경이다. -> 변경이 있을 때, 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것

★ 2. OCP : 개방-폐쇄 원칙 ★
- 소프트웨어 요소는 확장에는 열려있으나, 변경에는 닫혀 있어야 한다. -> 다형성을 활용
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현

* 문제점
MemberService 클라이언트가 구현 클래스를 직접 선택
ex)
MemberRepository m = new MemoryMemberRepository(); // 기존 코드
MemberRepository m = new JdbcMemberRepository() // 변경 코드

-> 구현 객체를 변경하려면 클라이언트 코드를 변경해야 함.
-> 분명 다형성을 이용했지만, OCP 원칙이 지켜지지 않음

3. LSP : 리스코프 치환 원칙
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함
- 다형성에서 하위 클래스는 인터페이스의 규약을 다 지켜야 한다.
ex)
자동차 인터페이스의 엑셀은 앞으로 가라는 기능. -> 뒤로 가게 구현하면 LSP 원칙 위배.

4. ISP : 인터페이스 분리 원칙
- 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다
ex) 
자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스
사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트

5. DIP : 의존관계 역전 원칙
- 프로그래머는 추상화에 의존해야 하지. 구체화에 의존하면 안된다.
- 구현 클래스에 의존하지 말고, 인터페이스에 의존 할 것 !


★ 정리
1. 객체 지향의 핵심은 다형성
2. 다형성 만으로는 쉽게 부품을 갈아 끼우듯 개발할 수 없다.
3. 다형성 만으로는 구현 객체를 변경할 때, 클라이언트 코드도 함께 변경된다.
4. 다형성 만으로는 OCP, DIP를 지킬 수 없다.
5. 다른 무언가가 더 필요하다.